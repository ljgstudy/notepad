### RabbitMQ集群-基本概念

---

#### 1、RabbitMQ高可用的两种方法

- 设置RabbitMQ集群
- 扩大程序的规模以提升性能

#### 2、集群架构

- 概述

  RabbitMQ会始终记录以下四种类型的内部元数据

  - 队列元数据 - 队列名称和它们的属性（是否持久化，是否自动删除）
  - 交换器元数据 - 交换器名称、类型和属性（可持久化等）
  - 绑定元数据 - 一张简单的表格展示了如何将消息路由到队列
  - vhost元数据 - 为vhost内的队列、交换器和绑定提供命名空间和安全属性

  在单一节点内，RabbitMQ会将所有的这些信息存储在内存中，同时将那些标记为可持久化的队列和交换器（以及他们的绑定）存储到磁盘上。存储到磁盘上可以确保队列和交换器在重启RabbitMQ节点后重新创建。当你引入集群时，RabbitMQ需要追踪新的元数据类型：集群节点位置，以及节点与已记录的其他类型元数据的关系。集群也提供了选择：将元数据存储到磁盘上（独立节点和默认设置），或者仅存储在RAM中。

- 队列

  - 不是每一个节点都有所有队列的完全拷贝。集群只会在单个节点而不是在所有节点上创建完整的队列信息（元数据、状态和内容）

  - 队列的所有者知道有关队列的所有信息，其他非所有节点只知道队列的元数据和指向该队列存在的那个节点的指针

  - 队列内容和状态不复制到所有节点上的原因：

    - 存储空间 - 如果每个集群节点都拥有所有队列的完整拷贝，那么添加新的节点不会给你带来更多的存储空间
    - 性能 - 消息的发布需要将消息复制到每一个集群节点。对于持久化消息来说，每一条消息都会出发磁盘活动。每次新增节点，网络和磁盘负载都会增加，最终只能保持集群性能的平稳，甚至更糟。

  - 单节点和集群环境中队列的形态

    <img src="https://i.loli.net/2020/07/26/eo7lwVu5xZvCIHD.png" alt="image-20200726105330766"  />

- 交换机

  理解RabbitMQ背后的消息路由机制的方法是把每个队列想象成节点上运行的进程，每个进程拥有自己的进程ID(PID)。交换器只不过是路由模式列表和匹配消息应发往的队列进程ID列表。当发布的消息匹配了交换器中的绑定规则时，实际上是由信道完成了匹配工作，并在匹配之后建立到队列PID的连接，然后将消息发送出去。

  - 集群中的每个节点拥有每个交换器的所有信息
  - 消息发布到信道上，但在路由完成之前节点发生故障，消息将会有丢失的风险。解决方案：
    - 使用AMQP事务，在消息路由到队列之前他会一直阻塞
    - 使用发送方确认（publisher confirm）模式来记录连接中断时尚未被确认的消息

- 内存节点还是磁盘节点

  - 不管是单一节点系统还是庞大集群的一部分，要么是内存节点（RAM node），要么是磁盘节点（disk node）

  - 内存节点将所有的队列、交换器、绑定、用户、权限和vhost的元数据定义都仅存储在内存中

  - 磁盘节点将元数据存储在磁盘中

  - 单节点系统只允许磁盘类型的节点

  - 在集群中，可以配置部分节点为内存节点

    ![image-20200726111021554](https://i.loli.net/2020/07/26/UQEC2XcrZB61VhD.png)

  - 当在集群中生命队列、交换器或者绑定的时候，这些操作会直到所有集群节点都成功提交元数据变更后才返回

    - 对于内存节点，这意味着将变更写入内存
    - 对于磁盘节点，这意味着昂贵的磁盘写入操作，假设集群中有五个节点，并且所有的节点都是磁盘节点，则你必须得等待所有这五个节点将元数据写入磁盘后，队列声明操作才能返回

  - RabbitMQ只要求在集群中至少有一个磁盘节点。所有其他节点可以是内存节点。当节点加入后者离开集群时，他们必须要将变更通知到至少一个磁盘节点

  - 集群中唯一的磁盘节点崩溃的话，集群仍然可以保持运行，但是直到该节点恢复到集群前，你无法更改任何东西。